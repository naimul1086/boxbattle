<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Box Battle - Dots & Boxes</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap');

        body {
            font-family: 'Fredoka', sans-serif;
            background-color: #1a202c;
            color: #e2e8f0;
            overflow-x: hidden;
            touch-action: manipulation;
        }

        #game-wrapper {
            position: relative;
            width: 100%;
            max-width: 500px;
            margin: 0 auto;
            aspect-ratio: 1 / 1;
        }

        svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: visible;
        }

        .line {
            stroke-linecap: round;
            transition: stroke 0.2s ease, filter 0.2s ease;
            cursor: pointer;
        }

        .line:hover:not(.active) {
            stroke: rgba(255, 255, 255, 0.3);
        }

        .line.active {
            cursor: default;
        }

        .dot {
            pointer-events: none;
            z-index: 10;
        }

        .box-fill {
            opacity: 0;
            transition: opacity 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .box-fill.completed {
            opacity: 1;
        }

        .p1-color { color: #3b82f6; }
        .p2-color { color: #ef4444; }
        
        .p1-bg { background-color: #3b82f6; }
        .p2-bg { background-color: #ef4444; }

        .p1-stroke { stroke: #3b82f6; }
        .p2-stroke { stroke: #ef4444; }

        .p1-fill { fill: rgba(59, 130, 246, 0.4); }
        .p2-fill { fill: rgba(239, 68, 68, 0.4); }

        @keyframes pulse-border {
            0% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(255, 255, 255, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0); }
        }

        .turn-active {
            animation: pulse-border 2s infinite;
            border-color: white;
        }

        .modal-backdrop {
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }

        #confetti-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
        }

        .thinking-dot {
            animation: bounce 1.4s infinite ease-in-out both;
        }

        .thinking-dot:nth-child(1) { animation-delay: -0.32s; }
        .thinking-dot:nth-child(2) { animation-delay: -0.16s; }

        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }

        .mode-btn {
            transition: all 0.3s ease;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: transparent;
            color: white;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-4">

    <!-- Setup Modal (Shown on first load) -->
    <div id="setup-modal" class="fixed inset-0 modal-backdrop flex items-center justify-center z-50">
        <div class="bg-gray-800 p-8 rounded-3xl max-w-md w-full mx-4 shadow-2xl border border-gray-700">
            <h1 class="text-4xl font-bold text-center mb-2 bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-red-400">
                BOX BATTLE
            </h1>
            <p class="text-center text-gray-400 mb-8">Dots & Boxes Game</p>

            <!-- Game Mode Selection -->
            <div class="mb-6">
                <label class="block text-gray-400 text-sm font-bold mb-3 text-center">Select Game Mode</label>
                <div class="grid grid-cols-2 gap-4">
                    <button class="mode-btn active p-4 rounded-xl border-2 border-gray-600 hover:border-gray-500 flex flex-col items-center gap-2" data-mode="pvp">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197M13 7a4 4 0 11-8 0 4 4 0 018 0z" />
                        </svg>
                        <span class="font-semibold">vs Player</span>
                    </button>
                    <button class="mode-btn p-4 rounded-xl border-2 border-gray-600 hover:border-gray-500 flex flex-col items-center gap-2" data-mode="pvc">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
                        </svg>
                        <span class="font-semibold">vs Computer</span>
                    </button>
                </div>
            </div>

            <!-- Player Names -->
            <div class="space-y-4 mb-8">
                <div>
                    <label class="block text-blue-400 text-xs font-bold uppercase mb-1">Player 1 Name</label>
                    <input type="text" id="p1-name-input" value="Player 1" maxlength="12" 
                        class="w-full px-4 py-3 bg-gray-700 rounded-xl border-2 border-gray-600 focus:border-blue-500 focus:outline-none text-white font-semibold transition">
                </div>
                <div>
                    <label class="block text-red-400 text-xs font-bold uppercase mb-1" id="p2-label">Player 2 Name</label>
                    <input type="text" id="p2-name-input" value="Player 2" maxlength="12" 
                        class="w-full px-4 py-3 bg-gray-700 rounded-xl border-2 border-gray-600 focus:border-red-500 focus:outline-none text-white font-semibold transition">
                </div>
            </div>

            <!-- Grid Size Selection -->
            <div class="mb-8">
                <label class="block text-gray-400 text-sm font-bold mb-3 text-center">Grid Size</label>
                <div class="grid grid-cols-3 gap-3">
                    <button class="grid-select-btn py-2 rounded-lg border-2 border-gray-600 hover:border-gray-500 font-semibold transition" data-size="4">4√ó4</button>
                    <button class="grid-select-btn py-2 rounded-lg border-2 border-blue-500 bg-blue-500/20 text-blue-400 font-semibold transition" data-size="5">5√ó5</button>
                    <button class="grid-select-btn py-2 rounded-lg border-2 border-gray-600 hover:border-gray-500 font-semibold transition" data-size="6">6√ó6</button>
                </div>
            </div>

            <button id="start-game-btn" class="w-full py-4 bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-400 hover:to-purple-500 rounded-xl font-bold text-lg shadow-lg transform transition hover:scale-105">
                Start Game
            </button>
        </div>
    </div>

    <!-- Main Game UI (Hidden initially) -->
    <div id="game-ui" class="w-full max-w-lg hidden opacity-0 transition-opacity duration-500">
        
        <!-- Header / Scoreboard -->
        <header class="w-full mb-6 flex flex-col gap-4">
            <div class="flex justify-between items-center">
                <h1 class="text-3xl font-bold tracking-wider bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-red-400">
                    BOX BATTLE
                </h1>
                <div class="flex gap-2">
                    <button id="new-game-btn" class="text-gray-400 hover:text-white transition p-2" title="New Game">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 15l-3-3m0 0l3-3m-3 3h8M3 12a9 9 0 1118 0 9 9 0 01-18 0z" />
                        </svg>
                    </button>
                    <button id="settings-btn" class="text-gray-400 hover:text-white transition p-2">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                        </svg>
                    </button>
                </div>
            </div>

            <!-- Score Board -->
            <div class="grid grid-cols-2 gap-4">
                <div id="p1-card" class="bg-gray-800 p-4 rounded-xl border-2 border-blue-500 transition-all duration-300 transform scale-105 shadow-lg shadow-blue-900/20 relative overflow-hidden">
                    <div class="absolute top-2 right-2 w-3 h-3 rounded-full bg-blue-500 animate-pulse" id="p1-indicator"></div>
                    <div class="text-xs text-blue-400 uppercase font-bold" id="p1-name-display">Player 1</div>
                    <div class="text-3xl font-bold p1-color" id="score-p1">0</div>
                </div>
                <div id="p2-card" class="bg-gray-800 p-4 rounded-xl border-2 border-gray-700 transition-all duration-300 opacity-70 relative overflow-hidden">
                    <div class="absolute top-2 right-2 w-3 h-3 rounded-full bg-red-500 opacity-0" id="p2-indicator"></div>
                    <div class="text-xs text-red-400 uppercase font-bold flex items-center gap-2" id="p2-name-display">
                        Player 2
                        <span id="thinking-indicator" class="hidden flex gap-1">
                            <span class="w-1.5 h-1.5 bg-red-400 rounded-full thinking-dot"></span>
                            <span class="w-1.5 h-1.5 bg-red-400 rounded-full thinking-dot"></span>
                            <span class="w-1.5 h-1.5 bg-red-400 rounded-full thinking-dot"></span>
                        </span>
                    </div>
                    <div class="text-3xl font-bold p2-color" id="score-p2">0</div>
                </div>
            </div>
            
            <div class="text-center text-sm text-gray-400" id="turn-indicator">Player 1's Turn</div>
        </header>

        <!-- Game Area -->
        <main class="w-full relative">
            <div id="game-wrapper">
                <svg id="game-svg" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid meet">
                    <g id="layer-boxes"></g>
                    <g id="layer-lines"></g>
                    <g id="layer-dots"></g>
                </svg>
            </div>
        </main>

        <!-- Controls -->
        <footer class="mt-8 flex gap-4 justify-center">
            <button id="restart-btn" class="px-6 py-3 bg-gray-700 hover:bg-gray-600 rounded-full font-bold transition shadow-lg flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd" />
                </svg>
                Restart
            </button>
        </footer>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="fixed inset-0 modal-backdrop hidden flex items-center justify-center z-40 opacity-0 transition-opacity duration-300">
        <div class="bg-gray-800 p-6 rounded-2xl max-w-sm w-full mx-4 shadow-2xl transform scale-95 transition-transform duration-300 border border-gray-700">
            <h2 class="text-2xl font-bold mb-4 text-white">Settings</h2>
            
            <div class="mb-6">
                <label class="block text-gray-400 text-sm font-bold mb-2">Sound</label>
                <button id="sound-toggle" class="w-full py-2 bg-green-600 hover:bg-green-500 rounded-lg font-bold transition">ON</button>
            </div>

            <button id="close-settings" class="w-full py-3 bg-gray-700 hover:bg-gray-600 rounded-xl font-bold transition">Close</button>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div id="game-over-modal" class="fixed inset-0 modal-backdrop hidden flex items-center justify-center z-50">
        <div class="bg-gray-800 p-8 rounded-3xl max-w-sm w-full mx-4 shadow-2xl text-center border border-gray-700 transform scale-0 transition-transform duration-500" id="game-over-content">
            <div class="mb-4 text-6xl">üèÜ</div>
            <h2 class="text-3xl font-bold mb-2 text-white" id="winner-text">Player 1 Wins!</h2>
            <p class="text-gray-400 mb-8" id="final-score">5 - 3</p>
            <div class="flex gap-3">
                <button id="play-again-btn" class="flex-1 py-4 bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-400 hover:to-purple-500 rounded-xl font-bold text-lg shadow-lg transform transition hover:scale-105">
                    Play Again
                </button>
                <button id="menu-btn" class="flex-1 py-4 bg-gray-700 hover:bg-gray-600 rounded-xl font-bold text-lg shadow-lg transform transition hover:scale-105">
                    Menu
                </button>
            </div>
        </div>
    </div>

    <canvas id="confetti-canvas"></canvas>

    <script>
        /**
         * BOX BATTLE - GAME LOGIC WITH AI & CUSTOM NAMES
         */

        // --- Audio System ---
        let audioEnabled = true;
        let synth, membrane, metal;

        async function initAudio() {
            if (!audioEnabled) return;
            await Tone.start();
            
            synth = new Tone.PolySynth(Tone.Synth).toDestination();
            synth.volume.value = -10;
            membrane = new Tone.MembraneSynth().toDestination();
            membrane.volume.value = -15;
            metal = new Tone.MetalSynth({
                frequency: 200,
                envelope: { attack: 0.001, decay: 0.1, release: 0.01 },
                harmonicity: 5.1,
                modulationIndex: 32,
                resonance: 4000,
                octaves: 1.5
            }).toDestination();
            metal.volume.value = -20;
        }

        function playSound(type) {
            if (!audioEnabled || !synth) return;
            try {
                switch(type) {
                    case 'click': synth.triggerAttackRelease("C5", "32n"); break;
                    case 'box':
                        membrane.triggerAttackRelease("C2", "16n");
                        metal.triggerAttackRelease("32n", "+0.05");
                        synth.triggerAttackRelease(["C5", "E5", "G5"], "16n");
                        break;
                    case 'win':
                        const now = Tone.now();
                        metal.triggerAttackRelease("16n", now);
                        metal.triggerAttackRelease("16n", now + 0.1);
                        metal.triggerAttackRelease("16n", now + 0.2);
                        synth.triggerAttackRelease(["C4", "E4", "G4", "C5"], "8n", now);
                        break;
                    case 'error': synth.triggerAttackRelease(["C3", "C#3"], "16n"); break;
                }
            } catch(e) { console.error("Audio error", e); }
        }

        // --- Game State ---
        const state = {
            gridSize: 5,
            currentPlayer: 1,
            scores: { 1: 0, 2: 0 },
            lines: new Set(),
            boxes: {},
            gameOver: false,
            totalBoxes: 0,
            gameMode: 'pvp',
            playerNames: { 1: 'Player 1', 2: 'Player 2' },
            isComputerThinking: false
        };

        // --- DOM Elements ---
        const svg = document.getElementById('game-svg');
        const layerLines = document.getElementById('layer-lines');
        const layerBoxes = document.getElementById('layer-boxes');
        const layerDots = document.getElementById('layer-dots');
        const scoreEls = { 1: document.getElementById('score-p1'), 2: document.getElementById('score-p2') };
        const cardEls = { 1: document.getElementById('p1-card'), 2: document.getElementById('p2-card') };
        const nameEls = { 1: document.getElementById('p1-name-display'), 2: document.getElementById('p2-name-display') };
        const indicatorEls = { 1: document.getElementById('p1-indicator'), 2: document.getElementById('p2-indicator') };
        const turnIndicator = document.getElementById('turn-indicator');
        const thinkingIndicator = document.getElementById('thinking-indicator');

        // --- AI Logic (Fixed) ---
        function getAvailableLines() {
            const available = [];
            const size = state.gridSize;
            
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size - 1; c++) {
                    const key = `${r},${c},h`;
                    if (!state.lines.has(key)) {
                        available.push({r, c, dir: 'h', key});
                    }
                }
            }
            for (let r = 0; r < size - 1; r++) {
                for (let c = 0; c < size; c++) {
                    const key = `${r},${c},v`;
                    if (!state.lines.has(key)) {
                        available.push({r, c, dir: 'v', key});
                    }
                }
            }
            return available;
        }

        function countBoxSides(r, c) {
            const top = `${r},${c},h`;
            const bottom = `${r+1},${c},h`;
            const left = `${r},${c},v`;
            const right = `${r},${c+1},v`;
            
            let count = 0;
            if (state.lines.has(top)) count++;
            if (state.lines.has(bottom)) count++;
            if (state.lines.has(left)) count++;
            if (state.lines.has(right)) count++;
            return count;
        }

        function wouldCompleteBox(r, c, dir) {
            if (dir === 'h') {
                if (r > 0 && countBoxSides(r-1, c) === 3) return true;
                if (r < state.gridSize - 1 && countBoxSides(r, c) === 3) return true;
            } else {
                if (c > 0 && countBoxSides(r, c-1) === 3) return true;
                if (c < state.gridSize - 1 && countBoxSides(r, c) === 3) return true;
            }
            return false;
        }

        function findBestMove() {
            const available = getAvailableLines();
            console.log("Available moves:", available.length);
            
            if (available.length === 0) return null;
            
            // Priority 1: Complete a box if possible
            const completingMoves = [];
            for (const move of available) {
                if (wouldCompleteBox(move.r, move.c, move.dir)) {
                    completingMoves.push(move);
                }
            }
            
            if (completingMoves.length > 0) {
                console.log("Found completing move");
                return completingMoves[Math.floor(Math.random() * completingMoves.length)];
            }
            
            // Priority 2: Find safe moves (don't give opponent a box)
            const safeMoves = [];
            const riskyMoves = [];
            
            for (const move of available) {
                // Temporarily add the line
                state.lines.add(move.key);
                
                // Check if this enables opponent to complete any box
                let givesBoxToOpponent = false;
                
                // Check all remaining available lines to see if any would now complete a box
                const remaining = getAvailableLines();
                for (const nextMove of remaining) {
                    if (wouldCompleteBox(nextMove.r, nextMove.c, nextMove.dir)) {
                        givesBoxToOpponent = true;
                        break;
                    }
                }
                
                // Remove the temporary line
                state.lines.delete(move.key);
                
                if (!givesBoxToOpponent) {
                    safeMoves.push(move);
                } else {
                    riskyMoves.push(move);
                }
            }
            
            if (safeMoves.length > 0) {
                console.log("Playing safe move");
                return safeMoves[Math.floor(Math.random() * safeMoves.length)];
            }
            
            // All moves are risky, pick random
            console.log("Playing risky move");
            return riskyMoves[Math.floor(Math.random() * riskyMoves.length)];
        }

        async function computerMove() {
            if (state.gameOver || state.currentPlayer !== 2) return;
            
            state.isComputerThinking = true;
            thinkingIndicator.classList.remove('hidden');
            
            await new Promise(r => setTimeout(r, 800 + Math.random() * 600));
            
            if (state.gameOver) {
                thinkingIndicator.classList.add('hidden');
                state.isComputerThinking = false;
                return;
            }
            
            const move = findBestMove();
            console.log("Computer move:", move);
            
            if (move) {
                // Use processMove directly instead of handleLineClick to avoid turn check
                processMove(move.r, move.c, move.dir, move.key);
            } else {
                console.log("No moves available");
            }
            
            thinkingIndicator.classList.add('hidden');
            state.isComputerThinking = false;
        }

        // --- Game Logic ---
        function initGame(size = 5, mode = 'pvp', names = {1: 'Player 1', 2: 'Player 2'}) {
            state.gridSize = size;
            state.gameMode = mode;
            state.playerNames = names;
            state.currentPlayer = 1;
            state.scores = { 1: 0, 2: 0 };
            state.lines.clear();
            state.boxes = {};
            state.gameOver = false;
            state.totalBoxes = (size - 1) * (size - 1);
            state.isComputerThinking = false;
            
            nameEls[1].textContent = names[1];
            nameEls[2].textContent = names[2];
            
            updateScoreboard();
            updateTurnUI();
            renderGrid();
            
            document.getElementById('game-over-modal').classList.add('hidden');
            document.getElementById('game-over-content').classList.remove('scale-100');
            document.getElementById('game-over-content').classList.add('scale-0');
            thinkingIndicator.classList.add('hidden');
        }

        function renderGrid() {
            layerLines.innerHTML = '';
            layerBoxes.innerHTML = '';
            layerDots.innerHTML = '';

            const size = state.gridSize;
            const step = 100 / (size - 1);

            for (let r = 0; r < size - 1; r++) {
                for (let c = 0; c < size - 1; c++) {
                    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    rect.setAttribute("x", c * step);
                    rect.setAttribute("y", r * step);
                    rect.setAttribute("width", step);
                    rect.setAttribute("height", step);
                    rect.setAttribute("rx", step * 0.1);
                    rect.setAttribute("class", "box-fill");
                    rect.setAttribute("id", `box-${r}-${c}`);
                    layerBoxes.appendChild(rect);
                }
            }

            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size - 1; c++) {
                    createLine(r, c, 'h', step);
                }
            }
            for (let r = 0; r < size - 1; r++) {
                for (let c = 0; c < size; c++) {
                    createLine(r, c, 'v', step);
                }
            }

            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    circle.setAttribute("cx", c * step);
                    circle.setAttribute("cy", r * step);
                    circle.setAttribute("r", step * 0.12);
                    circle.setAttribute("fill", "#4a5568");
                    circle.setAttribute("class", "dot");
                    layerDots.appendChild(circle);
                }
            }
        }

        function createLine(r, c, dir, step) {
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            const isHoriz = dir === 'h';
            
            const x1 = c * step;
            const y1 = r * step;
            const x2 = isHoriz ? (c + 1) * step : c * step;
            const y2 = isHoriz ? r * step : (r + 1) * step;

            const hitArea = document.createElementNS("http://www.w3.org/2000/svg", "line");
            hitArea.setAttribute("x1", x1);
            hitArea.setAttribute("y1", y1);
            hitArea.setAttribute("x2", x2);
            hitArea.setAttribute("y2", y2);
            hitArea.setAttribute("stroke", "transparent");
            hitArea.setAttribute("stroke-width", step * 0.4);
            hitArea.style.cursor = "pointer";
            
            line.setAttribute("x1", x1);
            line.setAttribute("y1", y1);
            line.setAttribute("x2", x2);
            line.setAttribute("y2", y2);
            line.setAttribute("stroke", "#2d3748");
            line.setAttribute("stroke-width", step * 0.15);
            line.setAttribute("class", "line");
            line.setAttribute("id", `line-${r}-${c}-${dir}`);

            hitArea.addEventListener('click', () => handleLineClick(r, c, dir));
            line.addEventListener('click', () => handleLineClick(r, c, dir));

            layerLines.appendChild(line);
            layerLines.appendChild(hitArea);
        }

        function handleLineClick(r, c, dir) {
            if (state.gameOver || state.isComputerThinking) return;
            
            // In PVC mode, only player 1 can click
            if (state.gameMode === 'pvc' && state.currentPlayer === 2) {
                console.log("Computer's turn, ignoring click");
                return;
            }
            
            const key = `${r},${c},${dir}`;
            if (state.lines.has(key)) {
                playSound('error');
                return;
            }

            if (Tone.context.state !== 'running') {
                initAudio();
            }

            processMove(r, c, dir, key);
        }

        function processMove(r, c, dir, key) {
            console.log("Processing move:", r, c, dir, "by player", state.currentPlayer);
            
            state.lines.add(key);
            const lineEl = document.getElementById(`line-${r}-${c}-${dir}`);
            lineEl.setAttribute("stroke", state.currentPlayer === 1 ? "#3b82f6" : "#ef4444");
            lineEl.classList.add("active");
            
            playSound('click');

            const completedBoxes = checkBoxes(r, c, dir);
            console.log("Completed boxes:", completedBoxes.length);
            
            if (completedBoxes.length > 0) {
                // Player gets another turn
                completedBoxes.forEach(box => {
                    state.boxes[`${box.r},${box.c}`] = state.currentPlayer;
                    state.scores[state.currentPlayer]++;
                    
                    const boxEl = document.getElementById(`box-${box.r}-${box.c}`);
                    boxEl.classList.add("completed");
                    boxEl.classList.add(state.currentPlayer === 1 ? "p1-fill" : "p2-fill");
                });
                
                playSound('box');
                updateScoreboard();
                
                if (state.scores[1] + state.scores[2] === state.totalBoxes) {
                    endGame();
                    return;
                }
                
                // If computer just scored, it goes again
                if (state.gameMode === 'pvc' && state.currentPlayer === 2) {
                    setTimeout(computerMove, 500);
                }
                // If player scored in PVC mode, they go again (don't switch)
                // If player scored in PVP mode, they go again (don't switch)
            } else {
                // Switch Player
                state.currentPlayer = state.currentPlayer === 1 ? 2 : 1;
                updateTurnUI();
                
                // Trigger computer move if it's computer's turn
                if (state.gameMode === 'pvc' && state.currentPlayer === 2 && !state.gameOver) {
                    console.log("Triggering computer move");
                    setTimeout(computerMove, 500);
                }
            }
        }

        function checkBoxes(r, c, dir) {
            const completed = [];
            if (dir === 'h') {
                if (r > 0 && isBoxComplete(r - 1, c)) completed.push({r: r-1, c: c});
                if (r < state.gridSize - 1 && isBoxComplete(r, c)) completed.push({r: r, c: c});
            } else {
                if (c > 0 && isBoxComplete(r, c - 1)) completed.push({r: r, c: c-1});
                if (c < state.gridSize - 1 && isBoxComplete(r, c)) completed.push({r: r, c: c});
            }
            return completed;
        }

        function isBoxComplete(r, c) {
            const top = `${r},${c},h`;
            const bottom = `${r+1},${c},h`;
            const left = `${r},${c},v`;
            const right = `${r},${c+1},v`;
            
            return state.lines.has(top) && state.lines.has(bottom) && 
                   state.lines.has(left) && state.lines.has(right);
        }

        function updateScoreboard() {
            scoreEls[1].textContent = state.scores[1];
            scoreEls[2].textContent = state.scores[2];
        }

        function updateTurnUI() {
            const isP1 = state.currentPlayer === 1;
            
            cardEls[1].className = `bg-gray-800 p-4 rounded-xl border-2 transition-all duration-300 relative overflow-hidden ${isP1 ? 'border-blue-500 scale-105 shadow-lg shadow-blue-900/20' : 'border-gray-700 opacity-70'}`;
            cardEls[2].className = `bg-gray-800 p-4 rounded-xl border-2 transition-all duration-300 relative overflow-hidden ${!isP1 ? 'border-red-500 scale-105 shadow-lg shadow-red-900/20' : 'border-gray-700 opacity-70'}`;
            
            indicatorEls[1].style.opacity = isP1 ? '1' : '0';
            indicatorEls[2].style.opacity = !isP1 ? '1' : '0';
            
            const currentName = state.playerNames[state.currentPlayer];
            turnIndicator.textContent = `${currentName}'s Turn`;
            turnIndicator.className = `text-center text-sm font-bold ${isP1 ? 'text-blue-400' : 'text-red-400'}`;
        }

        function endGame() {
            state.gameOver = true;
            playSound('win');
            
            const p1 = state.scores[1];
            const p2 = state.scores[2];
            let winnerText = "";
            let colorClass = "";

            if (p1 > p2) {
                winnerText = `${state.playerNames[1]} Wins!`;
                colorClass = "text-blue-400";
            } else if (p2 > p1) {
                winnerText = `${state.playerNames[2]} Wins!`;
                colorClass = "text-red-400";
            } else {
                winnerText = "It's a Draw!";
                colorClass = "text-gray-200";
            }

            document.getElementById('winner-text').textContent = winnerText;
            document.getElementById('winner-text').className = `text-3xl font-bold mb-2 ${colorClass}`;
            document.getElementById('final-score').textContent = `${p1} - ${p2}`;

            const modal = document.getElementById('game-over-modal');
            const content = document.getElementById('game-over-content');
            
            modal.classList.remove('hidden');
            requestAnimationFrame(() => {
                content.classList.remove('scale-0');
                content.classList.add('scale-100');
            });

            startConfetti();
        }

        // --- Setup & Event Listeners ---
        const setupModal = document.getElementById('setup-modal');
        const gameUI = document.getElementById('game-ui');
        let selectedMode = 'pvp';
        let selectedSize = 5;

        // Mode selection
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                selectedMode = btn.dataset.mode;
                
                const p2Input = document.getElementById('p2-name-input');
                const p2Label = document.getElementById('p2-label');
                
                if (selectedMode === 'pvc') {
                    p2Input.value = 'Computer';
                    p2Input.disabled = true;
                    p2Label.textContent = 'Computer';
                } else {
                    p2Input.value = 'Player 2';
                    p2Input.disabled = false;
                    p2Label.textContent = 'Player 2 Name';
                }
            });
        });

        // Grid size selection
        document.querySelectorAll('.grid-select-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.grid-select-btn').forEach(b => {
                    b.className = 'grid-select-btn py-2 rounded-lg border-2 border-gray-600 hover:border-gray-500 font-semibold transition';
                });
                btn.className = 'grid-select-btn py-2 rounded-lg border-2 border-blue-500 bg-blue-500/20 text-blue-400 font-semibold transition';
                selectedSize = parseInt(btn.dataset.size);
            });
        });

        // Start game
        document.getElementById('start-game-btn').addEventListener('click', () => {
            const p1Name = document.getElementById('p1-name-input').value.trim() || 'Player 1';
            const p2Name = document.getElementById('p2-name-input').value.trim() || 'Player 2';
            
            initGame(selectedSize, selectedMode, {1: p1Name, 2: p2Name});
            
            setupModal.style.opacity = '0';
            setTimeout(() => {
                setupModal.classList.add('hidden');
                gameUI.classList.remove('hidden');
                setTimeout(() => gameUI.classList.remove('opacity-0'), 50);
            }, 300);
            
            initAudio();
        });

        // New game (back to menu)
        document.getElementById('new-game-btn').addEventListener('click', () => {
            gameUI.classList.add('opacity-0');
            setTimeout(() => {
                gameUI.classList.add('hidden');
                setupModal.classList.remove('hidden');
                setupModal.style.opacity = '1';
            }, 500);
        });

        document.getElementById('menu-btn').addEventListener('click', () => {
            document.getElementById('game-over-modal').classList.add('hidden');
            document.getElementById('new-game-btn').click();
        });

        // Restart
        document.getElementById('restart-btn').addEventListener('click', () => {
            initGame(state.gridSize, state.gameMode, state.playerNames);
        });

        document.getElementById('play-again-btn').addEventListener('click', () => {
            initGame(state.gridSize, state.gameMode, state.playerNames);
        });

        // Settings
        const settingsModal = document.getElementById('settings-modal');
        document.getElementById('settings-btn').addEventListener('click', () => {
            settingsModal.classList.remove('hidden');
            setTimeout(() => {
                settingsModal.classList.remove('opacity-0');
                settingsModal.querySelector('div').classList.remove('scale-95');
                settingsModal.querySelector('div').classList.add('scale-100');
            }, 10);
        });

        document.getElementById('close-settings').addEventListener('click', () => {
            settingsModal.classList.add('opacity-0');
            settingsModal.querySelector('div').classList.remove('scale-100');
            settingsModal.querySelector('div').classList.add('scale-95');
            setTimeout(() => settingsModal.classList.add('hidden'), 300);
        });

        document.getElementById('sound-toggle').addEventListener('click', function() {
            audioEnabled = !audioEnabled;
            this.textContent = audioEnabled ? "ON" : "OFF";
            this.className = audioEnabled 
                ? "w-full py-2 bg-green-600 hover:bg-green-500 rounded-lg font-bold transition"
                : "w-full py-2 bg-red-600 hover:bg-red-500 rounded-lg font-bold transition";
            if (audioEnabled) initAudio();
        });

        // Confetti
        const canvas = document.getElementById('confetti-canvas');
        const ctx = canvas.getContext('2d');
        let particles = [];

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function startConfetti() {
            particles = [];
            const colors = ['#3b82f6', '#ef4444', '#fbbf24', '#10b981', '#8b5cf6'];
            for (let i = 0; i < 150; i++) {
                particles.push({
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 0.5) * 15 - 5,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    size: Math.random() * 8 + 4,
                    rotation: Math.random() * 360,
                    rotationSpeed: (Math.random() - 0.5) * 10,
                    gravity: 0.2,
                    drag: 0.96
                });
            }
            animateConfetti();
        }

        function animateConfetti() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            particles.forEach((p, i) => {
                p.x += p.vx; p.y += p.vy;
                p.vy += p.gravity;
                p.vx *= p.drag; p.vy *= p.drag;
                p.rotation += p.rotationSpeed;
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate((p.rotation * Math.PI) / 180);
                ctx.fillStyle = p.color;
                ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
                ctx.restore();
                if (p.y > canvas.height) particles.splice(i, 1);
            });
            if (particles.length > 0) requestAnimationFrame(animateConfetti);
        }
    </script>
</body>
</html>
